{{Lowercase}}
'''backrooms''' uses a 3D memory space that holds a single Extended ASCII character per room “cell”.
It has 10 registers and 2 built in stacks per conscious "thread". Rules “instructions” can be more than one character long.
It also has 5 data types that can be used with the registers and stacks.
Data can be stored across multiple rooms and can be read as instructions during run-time or be re-read into data.

== About ==
{| class="wikitable"
!About
|-
| Author
| Charles McMarrow
|-
| User
| [[User:Ch44d]]
|-
| Conceived
| 5/22/2021
|-
| Birthday
| 8/16/21
|}

{| class="wikitable"
!Official Interpreter
|-
| '''pip install backrooms'''
|-
| https://github.com/cmcmarrow/backrooms
|}

{| class="wikitable"
!Inspiration
|-
| Backrooms Creepypasta/MEME
|-
| [[AsciiDots]]
|-
| CISC Architecture
|}

{| class="wikitable"
!Backrooms is designed to be:
|-
| Hackable VIA memory overflow attacks and poor error handling.
|-
| Visually pleasing.
|-
| Enjoyable to write small/medium programs.
|-
| Capable of rewriting all of a program at run-time.
|}

== Programs ==
=== Hello World ===
 ~GATE
 /rs"Hello World!"e~ha

=== bottles ===
 ~GATE
 /ri10ibri99>ers" bottles of beer on the wall, "epers" bottles of beer."epzez-V
 /V".llaw eht no reeb fo selttob "srepe" ,dnuora ti ssap dna nwod eno ekaT"sr.<
 /e>e~ha    1 >rs"1 bottle of beer on the wall, 1 bottle of beer."epers"Take one"epV
 /pp        p pVe".llaw eht no reeb fo selttob erom on ,dnuora ti ssap dna nwod "sr<
 /ze        . p>peers"No more bottles of beer on the wall, no more bottles of beer"V
 />...eezd-N^.^                                                                    e
 / ^".llaw eht no reeb fo selttob 99 ,erom emos yub dna erots eht ot oG"srepe"."srp<

=== [[truth-machine]] ===
 # 1 will echo forever and 0 will echo a single time.
 # Any other input will default to a 1.
 ~GATE
 /cicOvZVpri1V
 /    p >.e>NV~ha
 /    >ri1e^e<

=== fibonacci ===
 ~GATE
 /V         ah~<
 />ri0>dri18isZ^pdrs"FIB"V
 /    ^+pe" "srpech......<
 ~FIB
 />ZVdri3isLVpd-rs"FIB"hcz--rs"FIB"hciahr
 /rh<rh1irpp<

=== tic tac toe ===
 ~GATE
 />ri0>...+dri10isNVpprs"x"k0pri10ibrs"Tic Tac Toe!"epepri0V
 /.   .            p           a                    >p+....>dri9isNVpprs"E_BOARD"hcrs"Cats!"ep...V
 /.   .            d           h   >..rs"C_BOARD"hcZ^rs"E_BOARD"hceprs" won!"epri10ibeppVpebi01ir<
 /.   ^..hujbz"k"sr<           ~   ^................huch"DRAOB_U"sr<                    .
 /^...........................p^Zeb"a"srcpe+ >>+srpebi01irpe+!niaga yalp ot "a" retnE+sr<
 # Echo board
 ~E_BOARD
 />ri10ibrs"#"s1epes2epes3epzezeeeeezezs4epes5epes6epzezeeeeezezs7epes8epes9eppephr
 # Update board
 ~U_BOARD
 />rs"rs+"s0bjrs"+k"bjV                      >pbjrs"prs+"bjs0rs"x"beZVprs"o">bjrs"+k0p">bjhr
 /  Vpe0sch"DRAOB_E"sr<.pebi01irpe"RORRE"srpp^Nib"123456789"sr<      >prs"x"^
 /  >rs": "epcdri10ibeprs"1~2~3~4~5~6~7~8~9"biZVpdrs"s"zbjuh..^
 /                    ^....ebi01irpe"RORRE"srpp<
 # Check for winner
 ~C_BOARD
 /V                         >ppzphr
 />s5ds1beNVpd.....V    >beN^ppp..V                  >ppzphr
 /         >pds9beZVphr ^oupp<    3            V..ppp^Neb<
 /                 >pds3beNVpd.....V           .    >ppuo^
 /                         >pds7beZVphr  V+....<pppp^Nebou..hujbz"s"srai3ir<
 /                           2     >ppri0>dri3isNVpprs""hr                 z
 /         >rs"s"zbjuh..uobeN^pppp>d+....drs"s"z1pbjuh..zri3iadrs"s"zbjuh..^
 /         ^+z..hujbz"s"srd+z..hujbz"s"srd+mi3ird<

=== 8 bit ===
 ~GATE
 /V       >p~ha
 />ri512>Z^rs"READ"hcrs"INC"hcbjV
 /      ^-pebi01irpejbjbjbjbjbjb<
 ~READ
 />V
 ~INC
 /V>ri0k0pV        >p...V        >p...V        >p...V        >p...V        >p...V        >p...V        >p...V     rhp<
 /.     >2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV>2>1wri0s0Z^pV
 /.     ^................ch"PILF"sr<^................ch"PILF"sr<^................ch"PILF"sr<^................ch"PILF"sr<
 /.               rhp<^................ch"PILF"sr<^................ch"PILF"sr<^................ch"PILF"sr<.
 />rs"READ"hcri1k0rs"FLIP"hc..............................................................................^
 ~FLIP
 />iaZV-ZVri0hr
 /    d  r
 /    h  i
 /    r  1
 /       h
 /       r

=== dynamic ===
 ~GATE
 /rs"Vrs+hello!+epri10ibep"ri47ri0ri0ri0ri-1ri0ud
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /
 /                                               >~ha

== Rules ==
The rules "instructions" do not care if they are read up, down, left, right, etc, as long as the order of characters matches the rules signature. If a character does not match a rule backrooms will run NOP.
{| class="wikitable"
!Name
!Signatrue
!Action
!Example
|-
| style="vertical-align: top"| <code><nowiki>BackMirror</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>\</nowiki></span></code>
| style="vertical-align: top"| Changes Vector based off the direction the conscious comes from.
* <1, 0, 0> -> <0, -1, 0>
* <0, -1, 0> -> <1, 0, 0>
* <-1, 0, 0> -> <0, 1, 0>
* <0, 1, 0> -> <-1, 0, 0>
| style="vertical-align: top"|
 ~GATE
 /\    >~ha
 />....\.....<
 /     .     .
 /     \.....^
|-
| style="vertical-align: top"| <code><nowiki>BranchLessThanZero</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>L</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to LESS_THAN_ZERO.
|-
| style="vertical-align: top"| <code><nowiki>BranchGreaterThanZero</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>G</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to GREATER_THAN_ZERO.
|-
| style="vertical-align: top"| <code><nowiki>BranchZero</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>Z</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to ZERO.
|-
| style="vertical-align: top"| <code><nowiki>BranchNotZero</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>N</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to NOT_ZERO.
|-
| style="vertical-align: top"| <code><nowiki>BranchIsInteger</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>I</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to IS_INTEGER.
|-
| style="vertical-align: top"| <code><nowiki>BranchIsString</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>S</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to IS_STRING.
|-
| style="vertical-align: top"| <code><nowiki>BranchIsNone</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>O</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to IS_NONE.
|-
| style="vertical-align: top"| <code><nowiki>BranchIsStackFrame</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>F</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to IS_STACK_FRAME.
|-
| style="vertical-align: top"| <code><nowiki>BranchIsStackBottom</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>B</nowiki></span></code>
| style="vertical-align: top"| Sets branch condition to IS_STACK_BOTTOM.
|-
| style="vertical-align: top"| <code><nowiki>Cite</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>c</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[input, ...]
* <nowiki>Gets input from user and removes all characters not in <INPUT_CHARACTER>.</nowiki>
|
 ~GATE
 /ce~ha
|-
| style="vertical-align: top"| <code><nowiki>ClearStack</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>n</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[]
* Clears the Stack of all data.
|
 ~GATE
 /ri44rs"cats"ne~ha
Output
 StackBottom
|-
| style="vertical-align: top"| <code><nowiki>CoordinateX</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>x</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[x, ..]
* Gets conscious current x coordinate.
|-
| style="vertical-align: top"| <code><nowiki>CoordinateY</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>y</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[y, ..]
* Gets conscious current y coordinate.
|-
| style="vertical-align: top"| <code><nowiki>CoordinateFloor</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>f</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[floor, ..]
* Gets conscious current floor coordinate.
|-
| style="vertical-align: top"| <code><nowiki>Decrement</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>-</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ..]
* results = to_integer(item) - 1
* Subtract one to the item on top of the stack.
|
 ~GATE
 /ri40-e~ha
Output
 39
|-
| style="vertical-align: top"| <code><nowiki>Duplicate</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>d</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[item, item, ...]
* Copy the top item on the stack and place the copy onto the stack.
|
 ~GATE
 /ri10depe~ha
Output
 1010
|-
| style="vertical-align: top"| <code><nowiki>Echo</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>e</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[item, ...]
* Print the item on top of the stack onto the console.
|
 ~GATE
 /e~ha
|-
| style="vertical-align: top"| <code><nowiki>ForwardMirror</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>/</nowiki></span></code>
| style="vertical-align: top"| Changes Vector based off the direction the conscious comes from.
* <1, 0, 0> -> <0, 1, 0>
* <0, 1, 0> -> <1, 0, 0>
* <-1, 0, 0> -> <0, -1, 0>
* <0, -1, 0> -> <-1, 0, 0>
| style="vertical-align: top"|
 ~GATE
 /.....V
 /     .   /.~ha
 /     .   .
 /   /./.../
 /   . .
 /   . .
 /   >./
|-
| style="vertical-align: top"| <code><nowiki>HallwayCall</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hc</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, ...] -> WS[...]
* to_hallway(hallway)
* Jumps to a hallway on the same floor.
* Saves registers onto the Function Stack.
* If StackBottom is in a register it will be replaced by None when put on the Function Stack.
* The return location and current vector will also be saved onto the Function Stack.
| style="vertical-align: top"|
 ~GATE
 /ri3ri4rs"ADD"hc~ha
 ~ADD
 /iaephr
Output
 7
|-
| style="vertical-align: top"| <code><nowiki>HallwayLevelCall</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hl</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[...]
* to_hallway(hallway), to_floor(floor)
* Jumps to a hallway on any floor.
* Saves registers onto the Function Stack.
* If StackBottom is in a register it will be replaced by None when put on the Function Stack.
* The return location and current vector will also be saved onto the Function Stack.
| style="vertical-align: top"|
 ~GATE
 /ri3ri4rs"math"rs"ADD"hl~ha
 +math
 ~ADD
 /iaephr
Output
 7
|-
| style="vertical-align: top"| <code><nowiki>HallwayReturn</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hr</nowiki></span></code>
| style="vertical-align: top"|
* Restores registers.
* Jump back to return location.
* Restore vector.
|-
| style="vertical-align: top"| <code><nowiki>HallwayGetName</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hn</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[name, ...]
* to_integer(hallway), to_floor(floor)
* If no name exist None will be given back.
* The exact coordinates must be given.
|
 ~GATE
 /fyhne~ha
Output
 GATE
|-
| style="vertical-align: top"| <code><nowiki>HallwayGetLocation</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hg</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[y_location, ...]
* to_floor(floor)
* If hallway is not a String then it will to_integer.
* If no name exist None will be given back.
* As long as the y coordinate is with in the hallway the hallway location will be found.
* If coordinates are not in a hallway then None will be given back.
|
 ~GATE
 /frirs"Hallway"hge~ha
 ~Hallway
 /
Output
 -1
|-
| style="vertical-align: top"| <code><nowiki>HallwaySet</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hs</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, name, ...] -> WS[...]
* to_integer(hallway), to_floor(floor)
* If name is not None then it will to_string.
* Name must fit <NAME>.
* Will make a hallway and remove the hallway with the same name on the same floor if it exists.
|-
| style="vertical-align: top"| <code><nowiki>HallwayRemove</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hd</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[...]
* to_hallway(hallway), to_floor(floor)
* Will remove the specified hallway.
|-
| style="vertical-align: top"| <code><nowiki>HallwayPast</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>hp</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[y_location, ...]
* to_hallway(hallway), to_floor(floor)
* Will get the past hallway.
* If no past hallway exist then None will be given.
|
 ~GATE
 /fyhpe~ha
 ~Hallway
 /
Output
 -1
|-
| style="vertical-align: top"| <code><nowiki>HallwayNext</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>he</nowiki></span></code>
| style="vertical-align: top"| WS[hallway, floor, ...] -> WS[y_location, ...]
* to_hallway(hallway), to_floor(floor)
* Will get the next hallway.
* If no next hallway exist then None will be given.
|
 ~Hallway
 /
 ~GATE
 /fyhee~ha
Output
 0
|-
| style="vertical-align: top"| <code><nowiki>Halt</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>~ha</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will stop the program.
|
 ~GATE
 /~ha
|-
| style="vertical-align: top"| <code><nowiki>HopOne</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>1</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over one room.
|
 ~GATE
 /1^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopTwo</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>2</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over two rooms.
|
 ~GATE
 /2^^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopThree</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>3</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over three rooms.
|
 ~GATE
 /3^w^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopFour</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>4</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over four rooms.
|
 ~GATE
 /4^^^^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopFive</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>5</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over five rooms.
|
 ~GATE
 /5^OwO^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopSix</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>6</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over six rooms.
|
 ~GATE
 /6^^^^^^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopSeven</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>7</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over seven rooms.
|
 ~GATE
 /7^^^^^^^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopEighth</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>8</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over eighth rooms.
|
 ~GATE
 /8^^^^^^^^~ha
|-
| style="vertical-align: top"| <code><nowiki>HopNine</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>9</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will hop over nine rooms.
|
 ~GATE
 /9^^^^^^^^^~ha
|-
| style="vertical-align: top"| <code><nowiki>Increment</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>+</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* results = to_integer(item) + 1
* Add one to the item on top of the stack.
|
 ~GATE
 /ri40+e~ha
Output
 41
|-
| style="vertical-align: top"| <code><nowiki>IntegerCast</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ic</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* Intgerer -> Integer
* String -> Integer | None
* None -> None
* StackFrame -> None
* StackBottom -> None
|
 ~GATE
 /rs"+12"ice~ha
Output
 12
|-
| style="vertical-align: top"| <code><nowiki>IntegerAdd</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ia</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = item + item2
|
 ~GATE
 /ri3ri4iae~ha
Output
 7
|-
| style="vertical-align: top"| <code><nowiki>IntegerSubtract</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>is</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = item - item2
|
 ~GATE
 /ri3ri4ise~ha
Output
 -1
|-
| style="vertical-align: top"| <code><nowiki>IntegerMultiply</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>im</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = item * item2
|-
| style="vertical-align: top"| <code><nowiki>IntegerDivide</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>id</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = ⌊item / item2⌋
* results = None if operation causes a divide by zero.
|-
| style="vertical-align: top"| <code><nowiki>IntegerModular</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>io</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = item % item2
* results = None if operation causes a divide by zero.
|-
| style="vertical-align: top"| <code><nowiki>IntegerPower</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ip</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* results = ⌊item ** item2⌋
|-
| style="vertical-align: top"| <code><nowiki>IntegerByte</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ib</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* if to_integer(item) can be made into an Extended ASCII then that Extended ASCII character will be the results as a String.
* if to_integer(item) can't be made into an Extended ASCII then the results will be a None.
|
 ~GATE
 /ri67ibe~ha
Output
 c
|-
| style="vertical-align: top"| <code><nowiki>IntegerAbsolute</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>il</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* results = |to_integer(item)|
|
 ~GATE
 /ri-44ile~ha
Output
 44
|-
| style="vertical-align: top"| <code><nowiki>LevelGetFloorName</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ln</nowiki></span></code>
| style="vertical-align: top"| WS[floor_location, ...] -> WS[name, ...]
* to_integer(floor_loaction)
|-
| style="vertical-align: top"| <code><nowiki>LevelGetFloorLevel</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ll</nowiki></span></code>
| style="vertical-align: top"| WS[floor_name, ...] -> WS[f_location, ...]
* to_string(floor_name)
* If floor can't be found the f_location will be None.
|-
| style="vertical-align: top"| <code><nowiki>LevelSetFloorName</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ls</nowiki></span></code>
| style="vertical-align: top"| WS[floor_name, floor_location, ...] -> WS[...]
* to_string(floor_name) must fit <NAME>.
* to_integer(floor_loaction)
|-
| style="vertical-align: top"| <code><nowiki>NOP</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>.</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* No operation.
* Any time Backrooms cant find a rule Backrooms falls back to NOP.
|-
| style="vertical-align: top"| <code><nowiki>Keep</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>k</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[item, ...], R<DIGIT>: item
* Copy's the top item on the stack into the specific register.
|
 ~GATE
 /ri4k3ps3e~ha
Output
 4
|-
| style="vertical-align: top"| <code><nowiki>Pop</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>p</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[...]
* Pops the top item on top of the stack.
|-
| style="vertical-align: top"| <code><nowiki>PopFrame</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>a</nowiki></span></code>
| style="vertical-align: top"| WS[..., ...] -> WS[...]
* Pops items from the stack till a StackFrame or StackBottom is popped.
|
 ~GATE
 /ri4rfrs"cats"ri1ri-9ae~ha
Output
 4
|-
| style="vertical-align: top"| <code><nowiki>Read</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>r</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[item, ...]
* "ri" will try to read in an integer. If an invalid integer is found nothing will be placed onto the stack.
* "rs" will try to read in an String. If the String is never close then Backrooms will never stop running the rule.
* "rn" will load None onto the stack.
* "rf" will load StackFrame onto the stack.
|
 ~GATE
 /ri-44e~ha
Output
 -44

 ~GATE
 /rs@STRING@e~ha
Output
 STRING

 ~GATE
 /rne~ha
Output
 None

 ~GATE
 /rfe~ha
Output
 StackFrame
|-
| style="vertical-align: top"| <code><nowiki>ShifterRight</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>></nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <1, 0, 0>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|
 ~GATE
 /V
 />......V
 /       >......~ha

 ~GATE
 /ri0.N.V.Z.V
 /          >~ha

 ~GATE
 /....>>...!.!..V....^...V
 /                       >~ha
|-
| style="vertical-align: top"| <code><nowiki>ShifterLeft</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki><</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <-1, 0, 0>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>ShifterUp</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>^</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <0, 1, 0>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>ShifterDown</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>v</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <0, -1, 0>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>ShifterDownUpper</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>V</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <0, -1, 0>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>ShifterUpper</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>{</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <0, 0, 1>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>ShifterLower</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>}</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will set the current consciences vector to <0, 0, -1>
* If the Signature is repeated Immediately. The rule when enter fast mode.
* If the rule is in fast mode it will keep take steps till it hits another shifter.
* If the rule is in fast mode and sees "!" it will skip the next shift.
* If the rule is in fast mode "!" can stack.
* Shifter will only shift if the branch condition is meet.
* Shifters will always set the branch condition to Clear after checking it.
|-
| style="vertical-align: top"| <code><nowiki>Store</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>s</nowiki></span></code>
| style="vertical-align: top"| R<DIGIT>: item, WS[...] -> WS[item, ...], R<DIGIT>: item
* Copy's the item in specific register and put it on the Working Stack.
|-
| style="vertical-align: top"| <code><nowiki>StringLength</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bl</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* results = len(to_string(item))
|
 ~GATE
 /rs"cats"ble~ha
Output
 4
|-
| style="vertical-align: top"| <code><nowiki>StringCast</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bc</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* results = to_string(item)
|
 ~GATE
 /rnbce~ha
Output
 None
|-
| style="vertical-align: top"| <code><nowiki>StringAt</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ba</nowiki></span></code>
| style="vertical-align: top"| WS[at, item, ...] -> WS[results, ...]
* results = to_string(item)[to_integer(at)]
* If at is out of index results will be None.
* at can be negative and read the string backwards.
|
 ~GATE
 /rs"cats"ri1bae~ha
Output
 a
|-
| style="vertical-align: top"| <code><nowiki>StringByte</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bb</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* to_string(item)
* Gets the Extended ASCII Integer for the first characters from the String.
* If the String is empty then results will be None.
|
 ~GATE
 /rs"c"bbe~ha
Output
 67
|-
| style="vertical-align: top"| <code><nowiki>StringSplit</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bs</nowiki></span></code>
| style="vertical-align: top"| WS[at, item, ...] -> WS[front, back, ...]
* to_integer(at) to_string(item)
* If at is out of index the front or back will just be empty.
* at can be negative and split the string backwards.
|
 ~GATE
 /rs"12345"ri2bseprs" "epe~ha
Output
 12 345
|-
| style="vertical-align: top"| <code><nowiki>StringJoin</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bj</nowiki></span></code>
| style="vertical-align: top"| WS[back, front, ...] -> WS[results, ...]
* results = to_string(front) + to_string(back)
|
 ~GATE
 /rs"cats"rs" 0w0"bje~ha
Output
 cats 0w0
|-
| style="vertical-align: top"| <code><nowiki>StringEqual</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>be</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* to_string(item) == to_string(item2)
* results is 1 if Strings are equal.
* results is 0 if Strings are not equal.
|
 ~GATE
 /rs"cats"rs"cats"bee~ha
Output
 1
|-
| style="vertical-align: top"| <code><nowiki>StringEqual</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bi</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[results, ...]
* to_string(item) in to_string(item2)
* results is 1 if item is in item2.
* results is 0 if item is not in item2.
|
 ~GATE
 /rs"cats"rs"%^*&cats$"bie~ha
Output
 1
|-
| style="vertical-align: top"| <code><nowiki>StringUpper</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bu</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* to_string(item).upper()
* Will put the String into upper form.
|-
| style="vertical-align: top"| <code><nowiki>StringLower</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>bo</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* to_string(item).lower()
* Will put the String into lower form.
|-
| style="vertical-align: top"| <code><nowiki>StringReverse</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>br</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[results, ...]
* to_string(item).reverse()
* Will reverse the string.
|-
| style="vertical-align: top"| <code><nowiki>Switch</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>z</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[item, item2, ...]
* Will switch the top two items on the Working Stack.
|-
| style="vertical-align: top"| <code><nowiki>ThreadThread</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>tt</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will make a new conscious and copy registers, Working Stack, location and vector.
* The new conscious will get a ID that it not in use.
|
 ~GATE
 /ttrs"cats"e.~ha
Output
 catscats
|-
| style="vertical-align: top"| <code><nowiki>ThreadJoin</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>tj</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will terminate the conscious but not the program.
* The main conscious thread 0 wont terminate if it encounters this rule.
* If the conscious holds the ThreadLock it will be release.
|
 ~GATE
 /ttrs"cats"etje.~ha
Output
 catscatscats
|-
| style="vertical-align: top"| <code><nowiki>ThreadID</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ti</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[ID, ...]
* Will put the conscious ID on to the Working Stack.
|-
| style="vertical-align: top"| <code><nowiki>ThreadLock</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>tl</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will claim the ThreadLock if available if not the conscious will wait.
* A conscious can claim the ThreadLock multiple times which will stack.
|
 ~GATE
 /tttlrs"cats"eprs"0w0"etutj~ha
Output
 cats0w0cats0w0
|-
| style="vertical-align: top"| <code><nowiki>ThreadUnLock</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>tu</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[...]
* Will unlock a single thread lock if conscious has the lock.
|-
| style="vertical-align: top"| <code><nowiki>UncommonReadFlip</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ur</nowiki></span></code>
| style="vertical-align: top"| WS[...] -> WS[item, ...]
* Works just like the rule Read but after the read the rule will go back to the start and inverse the conscious vector.
* "uri" will try to read in an integer. If an invalid integer is found nothing will be placed onto the stack.
* "urs" will try to read in an String. If the String is never close then Backrooms will never stop running the rule.
* "urn" will load None onto the stack.
* "urf" will load StackFrame onto the stack.
|
 ~GATE
 /1Vuri44
 / >e~ha
Output
 44
|-
| style="vertical-align: top"| <code><nowiki>UncommonWriteFlip</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>uw</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[...]
* Works just like the rule Write but after the write the rule will go back to the start and inverse the conscious vector.
|
 ~GATE
 /ri44.1Vuw
 /      >e~ha

Memory
 ri44.1Vuw>1vuri44
       >e~ha

 ~GATE
 /rs"cats".1Vuw$
 /          >e~ha

Memory
 rs"cats".1Vuw$>1vurs$cats$
           >e~ha
|-
| style="vertical-align: top"| <code><nowiki>UncommonHotPatch</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>uh</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[...]
* to_string(item)
* Will write the data into the room cells after the rule.
|
 ~GATE
 /rs"rs+cats+e"uh.............~ha
Memory
 rs"rs+cats+e"uhrs+cats+e....~ha
|-
| style="vertical-align: top"| <code><nowiki>UncommonSimpleDump</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>us</nowiki></span></code>
| style="vertical-align: top"| WS[floor, y, x, item ,...] -> WS[...]
* to_floor(floor) to_integer(x) to_string(item)
* Will to_hallway(y) if y is not an Integer.
* Will write the data starting out the location <x, y, floor> given. The write vector is the current conscious vector.
|-
| style="vertical-align: top"| <code><nowiki>UncommonDynamicDump</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>ud</nowiki></span></code>
| style="vertical-align: top"| WS[v_floor, v_y, v_x, floor, y, x, item, ...] -> WS[...]
* to_integer(v_floor) to_integer(v_y) to_integer(v_x) to_floor(floor) to_integer(x) to_string(item)
* Will to_hallway(y) if y is not an Integer.
* Will write the data starting out the location <x, y, floor> given using the given vector <x_v, y_v, floor_v>.
|-
| style="vertical-align: top"| <code><nowiki>UncommonDoubleDuplicate</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>uo</nowiki></span></code>
| style="vertical-align: top"| WS[item2, item, ...] -> WS[item2, item, item2, item, ...]
* Will duplicate the first two items on top of the Working Stack.
|-
| style="vertical-align: top"| <code><nowiki>Write</nowiki></code>
| style="vertical-align: top"| <code><span style="color:red"><nowiki>w</nowiki></span></code>
| style="vertical-align: top"| WS[item, ...] -> WS[...]
* Will write the item into rooms and the next rule will be after the last write.
* If item is StackBottom item will become None.
|
 ~GATE
 /ri44w.....~ha
Memory
 ri44wri44.~ha

 ~GATE
 /rs"cats"w+........~ha
Memory
 rs"cats"w+rs+cats+~ha

 ~GATE
 /rnw+........~ha
Memory
 rnwrn.......~ha

 ~GATE
 /rfw.........~ha
Memory
 rfwrf.......~ha
|}

'''Convert Functions'''<br>
'''to_integer'''
{| class="wikitable"
!From
!To
|-
| style="text-align:center"| <code><nowiki>Integer</nowiki></code>
| <code><nowiki>Integer</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>String</nowiki></code>
| <code><nowiki>len(String)</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>None</nowiki></code>
| <code><nowiki>0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackFrame</nowiki></code>
| <code><nowiki>0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackBottom</nowiki></code>
| <code><nowiki>0</nowiki></code>
|}

'''to_string'''
{| class="wikitable"
!From
!To
|-
| style="text-align:center"| <code><nowiki>Integer</nowiki></code>
| <code><nowiki>str(Integer)</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>String</nowiki></code>
| <code><nowiki>String</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>None</nowiki></code>
| <code><nowiki>"None"</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackFrame</nowiki></code>
| <code><nowiki>"StackFrame"</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackBottom</nowiki></code>
| <code><nowiki>"StackBottom"</nowiki></code>
|}

'''to_hallway'''
{| class="wikitable"
!From
!To
|-
| style="text-align:center"| <code><nowiki>Integer</nowiki></code>
| <code><nowiki>Integer if hallway exist else 0, 0 if hallway exist else None</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>String</nowiki></code>
| <code><nowiki>Integer if hallway name exist else len(String), len(String) if hallway exist else 0, 0 if hallway exist else None</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>None</nowiki></code>
| <code><nowiki>0 if hallway exist else None</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackFrame</nowiki></code>
| <code><nowiki>0 if hallway exist else None</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackBottom</nowiki></code>
| <code><nowiki>0 if hallway exist else None</nowiki></code>
|}

'''to_floor'''
{| class="wikitable"
!From
!To
|-
| style="text-align:center"| <code><nowiki>Integer</nowiki></code>
| <code><nowiki>Integer</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>String</nowiki></code>
| <code><nowiki>Finds floor level, if name does not exist then len.(String)</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>None</nowiki></code>
| <code><nowiki>0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackFrame</nowiki></code>
| <code><nowiki>0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>StackBottom</nowiki></code>
| <code><nowiki>0</nowiki></code>
|}

== Memory ==
backrooms memory space is 3D with the axis X, Y, Floor every room "cell" holds <CHARACTER> and the default character is " ". Every axis is an integer. It is infinite in every direction. backrooms also allows some parts of the 3D memory space to be named <NAME>.

'''Floor:'''
Every Floor can be given its own name <NAME> or have the name of None. During runtime you can change or remove names. No two floors can have the same name. The last floor to be given the same name will keep it. The others will default to None. A Floor cord looks like <Floor>.

'''Hallways:'''
Every Floor can be given multiple Hallways. A Hallway an be given its own name <NAME> or have the name of None or not exist. A Hallway cord looks like <Y, Floor> X is all ways 0. No two hallways on the same floor can have the same name. The last hallway to be given the same name will keep it. The others will default to None on that floor.

== Data Types ==
{| class="wikitable"
!Type
!Description
|-
| style="text-align:center"| <code><nowiki>Integer</nowiki></code>
| -infinity to infinity
|-
| style="text-align:center"| <code><nowiki>String</nowiki></code>
| extended ASCII characters with a size 0 to infinity
|-
| style="text-align:center"| <code><nowiki>None</nowiki></code>
| null
|-
| style="text-align:center"| <code><nowiki>StackFrame</nowiki></code>
| indicates a frame on the stack
|-
| style="text-align:center"| <code><nowiki>StackBottom</nowiki></code>
| indicates that the stack is empty
|}

== Conscious ==
The conscious "thread" holds its own state. Each conscious gets it own registers, work stack, hallway stack, branch condition, vectors and thread id.

'''Registers'''<br>
Each conscious gets 10 registers which can store all 5 data types.

'''Work Stack''' <br>
The work stack allows an unlimited amount of data to be pushed onto it. Note: StackBottom cant be pushed onto the stack.

'''Hallway Stack'''<br>
Hallway "Function" Stack preserves registers, current location and current vector. When a the program makes a hallway call. The first hallway with "GATE" to be found is the program entry point.

'''Branch Condition'''
{| class="wikitable"
! Conditions
! Operation
|-
| style="text-align:center"| <code><nowiki>Clear</nowiki></code>
| <code><nowiki>True</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>LESS_THAN_ZERO</nowiki></code>
| <code><nowiki>to_integer(item) < 0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>GREATER_THAN_ZERO</nowiki></code>
| <code><nowiki>to_integer(item) > 0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>ZERO</nowiki></code>
| <code><nowiki>to_integer(item) == 0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>NOT_ZERO</nowiki></code>
| <code><nowiki>to_integer(item) != 0</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>IS_INTEGER</nowiki></code>
| <code><nowiki>type(item) == Integer</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>IS_STRING</nowiki></code>
| <code><nowiki>type(item) == String</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>IS_NONE</nowiki></code>
| <code><nowiki>type(item) == None</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>IS_STACK_FRAME</nowiki></code>
| <code><nowiki>type(item) == StackFrame</nowiki></code>
|-
| style="text-align:center"| <code><nowiki>IS_STACK_BOTTOM</nowiki></code>
| <code><nowiki>type(item) == StackBottom</nowiki></code>
|}

== Translator ==
The translator "assembler" of backrooms simplifies the way you can load a program into backrooms. It will ingest a script "file" or scripts and raise a syntax error if one is present.
The Translator throw's away any unnecessary <WHITESPACE>. The character "@" represents the data type None and the translator will replace "@" when necessary.
{| class="wikitable"
! Translator Definitions
! Description
|-
| style="vertical-align: top"| <nowiki><ROW> ::= "/" { <ROW_CHARACTER> } <NEWLINE></nowiki>
|
* will write the row characters to memory
* X axis will shift by 1 after every row character is written to memory
* will shift the Y axis by -1 when all writes are done
* X axis will reset to previous value when all writes are done
|-
| style="vertical-align: top"| <nowiki><COMMENT> ::= "#" { <COMMENT_CHARACTER> } <NEWLINE></nowiki>
|
* will just throw away the line
|-
| style="vertical-align: top"| <nowiki><HALLWAY> ::= "~" [ <NAME> | "@" ] <NEWLINE></nowiki>
|
* will make and set a hallway with the current location
|-
| style="vertical-align: top"| <nowiki><FLOOR> ::= "+" [ <NAME> | "@" ] <NEWLINE></nowiki>
|
* will set the name of a floor of the next floor
* will shift Floor axis by -1
|-
| style="vertical-align: top"| <nowiki><INCLUDE> ::= "%" <NAME> <NEWLINE></nowiki>
|
* will include another script if not all ready included
|-
| style="vertical-align: top"| <nowiki><MUST_INCLUDE> ::= "!" <NAME> <NEWLINE></nowiki>
|
* will include another script if not all ready included
* will raise an error if script is all ready included
|-
| style="vertical-align: top"| <nowiki><PARALLEL> ::= "=" [<NAME> | "@"] [<NAME> | "@"] [<NUMBER> | "@"] [<NUMBER> | "@"] <NEWLINE></nowiki>
|
* will copy a floor onto another floor
* arg 1: The name of the floor that will be copied
* arg 2: The name assigned to the floor you copy to
* arg 3: The location of the floor that will be copied
* arg 4: The location which the floor will be copied onto
* If arg 1 and arg 3 are both None then arg1 will default to current Floor
* If arg 4 is None then default to current Floor - 1 and shift Floor by an additional -1 once all of the script has been read
* Can't provide both arg 1 and arg3 at the same time
|-
| style="vertical-align: top"| <nowiki><X> ::= "X" <NUMBER> <NEWLINE></nowiki>
|
* will set the current X location
|-
| style="vertical-align: top"| <nowiki><XS> ::= "XS" <NUMBER> <NEWLINE></nowiki>
|
* will shift the current X location
|-
| style="vertical-align: top"| <nowiki><Y> ::= "Y" <NUMBER> <NEWLINE></nowiki>
|
* will set the current Y location
|-
| style="vertical-align: top"| <nowiki><YS> ::= "YS" <NUMBER> <NEWLINE></nowiki>
|
* will shift the current Y location
|-
| style="vertical-align: top"| <nowiki><F> ::= "F" <NUMBER> <NEWLINE></nowiki>
|
* will set the current Floor location
|-
| style="vertical-align: top"| <nowiki><FS> ::= "FS" <NUMBER> <NEWLINE></nowiki>
|
* will shift the current Floor location
|-
| style="vertical-align: top"| <nowiki><Translator> ::= {<ROW> | <COMMENT> | <HALLWAY> | <FLOOR> | <INCLUDE> | <MUST_INCLUDE> | <PARALLEL> | <X> | <XS> | <Y> | <YS> | <F> | <FS>}</nowiki>
|
* root definition for translator
|}

== Scripts ==
* Scripts can have the file extension ".brs" or no extension at all.
* Other Scripts in the same main directory can be included.
* The include check order is main directory then built-in directory of a script.

== Built-In Scripts  ==
Although its not necessary for a backrooms interpreter to supply built-in scripts. The official one does offer scripts that makes it much easier to allocate and store data. Built-In scripts are just like any other script.
{| class="wikitable"
!Scripts
!Descriptions
!Hallways
|-
| style="vertical-align: top"| <code><nowiki>h_vector</nowiki></code>
| style="vertical-align: top"| Servers as a vector use parallel to make a copy of the floor to have a vector.
|
* SIZE: WS[...] -> WS[size, ...]
* APPEND: WS[item, ...] -> WS[...]
* POP: WS[...] -> WS[item, ...]
* PEAK: WS[...] -> WS[item, ...]
* READ: WS[spot, ...] -> WS[item, ...]
* WRITE: WS[spot, item, ...] -> WS[item, ...]
* REMOVE: WS[spot, ...] -> WS[...]
* INSERT: WS[spot, item, ...] -> WS[...]
* FIND_INSERT: WS[item, ...] -> WS[...]
|-
| style="vertical-align: top"| <code><nowiki>heap</nowiki></code>
| style="vertical-align: top"| Allows a program to allocate blocks of memory to store data.
|
* AT: WS[AT, ID, ...] -> WS[ID, ...]
* NEW: WS[...] -> WS[ID, ...]
* NEW_A: WS[SIZE, ...] -> WS[ID, ...]
* READ: WS[ID, ...] -> WS[item, ...]
* READ_A: WS[AT, ID, ...] -> WS[item, ...]
* WRITE: WS[ID, item, ...] -> WS[...]
* WRITE_A: WS[AT, ID, item, ...] -> WS[...]
* FREE: WS[ID, ...] -> WS[...]
|-
| style="vertical-align: top"| <code><nowiki>heap_load</nowiki></code>
| style="vertical-align: top"| Used to include "heap".
|-
| style="vertical-align: top"| <code><nowiki>utils</nowiki></code>
| style="vertical-align: top"| Tools used to build other scripts.
|
* WSIZE: WS[item, ...] -> WS[string, ...]
* EMPTY_BLOCK: WS[block_size, ...] -> WS[empty_block_size, ...]
* TYPE_READ: WS[item, ...] -> WS[string, ...]
* KEEP: WS[y, f, item, ...] -> WS[...]
* STORE: WS[y, f, ...] -> WS[item, ...]
* CLEAR: WS[y, f, ...] -> WS[...]
* REMOVE: WS[y, f, ...] -> WS[...]
* NEW: WS[y, f, name, ...] -> WS[...]
|-
| style="vertical-align: top"| <code><nowiki>vars</nowiki></code>
| style="vertical-align: top"| Allows a program to get, set and delete a variable.
|
* GET: WS[name, ...] -> WS[item, ...]
* SET: WS[name item, ...] -> WS[...]
* DEL: WS[name, ...] -> WS[...]
|-
| style="vertical-align: top"| <code><nowiki>vars_load</nowiki></code>
| style="vertical-align: top"| Used to include "vars".
|}

== Meta-Language ==
{| class="wikitable"
!Type
!Description
|-
| style="text-align:center"| <code><nowiki>::=</nowiki></code>
|start to definition
|-
| style="text-align:center"| <code><nowiki>|</nowiki></code>
|alternative definition
|-
| style="text-align:center"| <code><nowiki>[]</nowiki></code>
| optional
|-
| style="text-align:center"| <code><nowiki>{}</nowiki></code>
| zero or more occurrences
|-
| style="text-align:center"| <code><nowiki>()</nowiki></code>
| only one occurrence
|-
| style="text-align:center"| <code><nowiki><X></nowiki></code>
| name of definition <X>
|-
| style="text-align:center"| <code><nowiki>"x"</nowiki></code>
| non-special symbol x
|-
| style="text-align:center"| <code><nowiki>"\""</nowiki></code>
| special symbol "
|-
| style="text-align:center"| <code><nowiki>\x120</nowiki></code>
| byte reputation of special symbol or symbol x
|}

{| class="wikitable"
!Meta-Language Implementation
|-
| <nowiki><DIGIT> ::= ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")</nowiki>
|-
| <nowiki><CHARACTER> ::= All extended ASCII characters excluding \x10.</nowiki>
|-
| <nowiki><COMMENT_CHARACTER> ::= All extended ASCII characters.</nowiki>
|-
| <nowiki><NUMBER> ::= ["+" | "-"] <DIGIT> {<DIGIT>}</nowiki>
|-
| <nowiki><LETTER> ::= a-z and A-Z</nowiki>
|-
| <nowiki><NAME> ::= (<LETTER> | <DIGIT> | "_") { <LETTERS> | <DIGIT> | "_" }</nowiki>
|-
| <nowiki><INPUT_CHARACTER> ::= (<LETTER> | <DIGIT> | "," | "<" | "." | "> " | "/" | "?" | ";" | ":" | "'" | "\"" | "[" | "{" | "]" | "}" | "\\" | "|" | "`" | "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "(" | ")" | "-" | "_" | "=" | "+" | " ")</nowiki>
|-
| <nowiki><ROW_CHARACTER> ::= (<LETTER> | <DIGIT> | "," | "<" | "." | "> " | "/" | "?" | ";" | ":" | "'" | "\"" | "[" | "{" | "]" | "}" | "\\" | "|" | "`" | "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "(" | ")" | "-" | "_" | "=" | "+" | " " | "~"</nowiki>)
|-
| <nowiki><NEWLINE> ::= "\n"</nowiki>
|-
| <nowiki><WHITESPACE> ::= {"\t" | "\r" | "\v" |"\f" | " "}</nowiki>
|}

[[Category:Implemented]]
[[Category:Languages]]
[[Category:Turing complete]]
[[Category:Cell-based]]
[[Category:Self-modifying]]
[[Category:Low-level]]
[[Category:2021]]
